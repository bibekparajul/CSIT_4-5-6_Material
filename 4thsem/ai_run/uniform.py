# -*- coding: utf-8 -*-
"""Lab 4 - Uniform Cost Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rnS4_cGx-boIaXPrCkthmJ6IltbjBp9m
"""

class UniformCostSearch():
    """
        Define a class for Uniform Cost Search
    """
    def __init__(self):
        self.que = []
        self.visited = []

    def get_path_cost(self, path):
        total_cost = 0
        for (n, cost) in path:
            total_cost += cost
        
        return total_cost

    def sort_queue(self):
        self.que.sort(key = lambda x: x[1])

    def expand_node(self, graph, v_node):
        for i, node in enumerate(graph[v_node[0]]):
            n = list(node)
            n[1] += v_node[1]
            node = tuple(n)
            graph[v_node[0]][i] = node

        self.que +=graph[v_node[0]]

        return graph

    def __call__(self, graph, start_node, goal_node):
        # Enqueue start node into the queue
        self.que = [(start_node, 0)]
        while goal_node not in self.visited:
            # Visit the node in the front of the queue
            v_node = self.que[0]
            del(self.que[0])

            print(self.que)
            # Insert the node into visited
            self.visited.extend(v_node[0])

            # Expand the visited node
            if v_node[0] in graph.keys():
                graph = self.expand_node(graph, v_node)
                    
            #Sort the element in Queue
            self.sort_queue()

        print("Visited Nodes are: ", self.visited)
        print("Total Cost is ", self.que[0][1])

# Consider a directed graph as below
graph = {
    'A' : [('B', 5), ('D', 3)],
    'B' : [('C', 1)],
    'D' : [('E', 2), ('F', 2)],
    'C' : [('E', 6), ('G', 8)],
    'F' : [('G', 3)]
}

start_node = 'A'
goal_node = 'G'

ucs = UniformCostSearch()
ucs(graph, start_node, goal_node)

