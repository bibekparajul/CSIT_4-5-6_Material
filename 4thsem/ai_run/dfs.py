# -*- coding: utf-8 -*-
"""Lab 3 - Depth First Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lPJFQKJTv5qNY8x3FZjOhkd_AxuV2L9Z

# Depth First Search

Depth First Searching is the searching technique used in AI for the possible goal within the depth of graph. DFS starts at start node or location of the problem and explores along its branch first until the goal node is found. If goal node is not found along the choosen branch, backtracking is run i.e. *looks for the goal node among all the children of the current node before using the sibling of this node i.e. expand deepest unexpanded node.*

The Depth First Search is implemented using Stack data structure and it is required to keep track of visited nodes to avoid cycle.

## Algorithm
1. Start by putting any one of the graph's vertices on top of a stack.
2. Pop out the vertices from top of the stack and add it to the visited list.
3. Expand the visited node and add its adjacent node that are not in the visited list to the top of the stack.
4. Repeat 2 and 3 utill goal node is found
"""

class DepthFirstSearch:
  """
    Scratch Implementation of Depth First Search in Python
  """
  def __init__(self, graph):
    self.graph = graph
    self.visited_list = set()
    self.visited = {}     # Status of element
    self.stack = []       # Stack to hold the element to maintain visit sequence
    self.markUnvisited()

  def markUnvisited(self):
    # Set all node as unvisited
    for node in self.getAllNodes():
      self.visited[node] = False

  def getAllNodes(self):
    s = set()
    for key, value in self.graph.items():
      s.add(key)
      for item in value:
        s.add(item)
    
    s = list(s)
    return s


  def isNodeVisited(self, node):
    if (not self.visited[node]):
      return True
    else:
      return False


  def is_child_node(self, node):
    for n, _ in self.graph.items():
      if n == node:
        return False
      
    return True


  def __call__(self, start_node):
    # Push start node to the top of the stack
    self.stack.append(start_node)

    print("Nodes in Stack: ", self.stack)

    while(len(self.stack)):
      # Visit the node in the top of stackx
      visit_node = self.stack.pop()

      print(f"Node {visit_node} has been visited.")
      self.visited[visit_node] = True

      # Once the node has been visited push node to the visited set.
      if visit_node not in self.visited_list:
        print(f"Visited node is {visit_node}")
        # Add visited node to the visited list
        self.visited_list.add(visit_node)

      # Check if node has adjacent node or is a child node
      if not self.is_child_node(visit_node):
        print(f"The {visit_node} is not a child node.")
        # Expand the visited node to its child or adjacent node and push them to the stack
        for adj_node in self.graph[visit_node]:
          if self.isNodeVisited(adj_node):
            self.stack.append(adj_node)
          else:
            print("The node doesn't have any child node.")
      else:
        print(f"visited node {visit_node} is a child node.")
      
      print("--------------------------------------------------------------------------------------------------")

graph = {
    'A' : ['B', 'C'],
    'B' : ['D', 'E'],
    'C' : ['F', 'G'],
    'E' : ['H', 'I']
}

dfs = DepthFirstSearch(graph)
print("Before DFS: ", dfs.visited)
dfs("A")
print("After DFS: ", dfs.visited)

"""## Analysis 

#### **Completeness**: It doesn't always return a solution even if it exists because if search space is infinite and search space contains loop then DFS may not find solution.

#### **Time Complexity**: 

#### **Space Complexity**: O(V), 

#### **Admisibility**: DFS expands to the deepest node first. It expands entire left sub-tree even if right subtree contains goal nodes at levels 2 or 3. Thus we can say DFS may not always give optimal solution.


"""

